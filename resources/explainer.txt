Hi. I'm gonna explain what is going on with the project and what I need you all to work on.


1. THE NFL FORMAT

First a little guide you can refer back to so you don't get lost in the following sections.

1.1. Nomenclature

The code in logic.cpp refers to Groups as "Divisions" because that's what they're actually called in the NFL,
but for the sake of aligning with the professor's nomenclature, I'll continue using "Group".
This also applies to the fact that logic.cpp refers to Matches as "Games".

In the NFL format, a Tournament is divided as follows:
1 TOURNAMENT -> 2 CONFERENCES
1 CONFERENCE -> 4 GROUPS (8 total)
1 GROUP -> 4 TEAMS (32 total)

The Groups are labeled Group A through Group H. The Teams can be named whatever, but for this explainer we will 
have them be named after the Group they're in and their position within it. For example, the third Team in 
Group B will be referred to as Team B3. 
The position of the Team within the Group only matters when deciding which other Teams they're gonna play against. 

1.2. Matches

A Match is played between two Teams: a home Team and an away Team. The home and away titles don't mean much 
aside from marking the order of the teams. 

When a Match is played, both Teams score a random set of points against each other. Depending on the outcome,
the Match is counted as either a win, loss, or tie accordingly for each Team. Say Team A1 plays Team E4 and the 
Match ends with a scoreboard of 7-4. Team A1 then adds 1 win to their record and Team E4 adds 1 loss.

Furthermore, each Team keeps track of a statistic called "net points," which is a metric of how well they 
played their Matches. After every Match, the points they scored are added to their net points and the points
they allowed the other team to score are subtracted from their net points. Following the previous example,
Team A1 would add 3 points to their net points and Team E4 would subtract 3 points from theirs.
This metric is employed during tie breakers.

1.3. Round Structure

The Tournament can be boiled down to 2 parts: The Regular Season (first round) and the Playoffs (four rounds).
The Regular Season is the only round in which Matches are allowed to end in a tie.

1.3.1. Regular Season

The first round (which is honestly like 10 rounds but we just call it one for consistency) has each Team play 
10 Matches against 10 very specific Teams. In total, there will be 160 Matches played.

    3 of the 10 Matches a Team plays in the Regular Season are against the other Teams in its Group. Taking
    Team B3 as our example, it will play against Teams B1, B2, and B4.
    All in all, the number of Group Matches played in each group is 6.

    Then, the 7 remaining Matches are played against every other Team in the same Group position. For Team B3,
    this means playing against Teams A3, C3, D3, E3, F3, G3, and H3.

After this, each Team calculates its win percentage with the formula:
WP = (# of wins + (# of ties * 0.5)) / 10

1.3.2. Playoff Bracket Formation

The Playoffs are basically 2 brackets played for each Conference, with the BIG BOWL being a Match between the
Conference champions. Each bracket includes 7 Teams, which is a wonky number for sure, but it'll make sense later.
The Teams that will fill each Conference's bracket are the following:

    Seeds #1 through #4 are the champions of the 4 Groups comprised by the Conference.

    A Group's champion is whichever Team has the highest win percentage. If more than one Team has the same 
    highest win percentage, the tie breaker rules are applied.

    To sort the champions themselves into the correct seeds, we simply order them by their win percentages, 
    with seed #1 having the highest and seed #4 the lowest. If more than one Team has the same win percentage, 
    the tie breaker rules are applied.

    The rest of the Teams that weren't Group champions are pooled together (12 total Teams). Then, the 3 Teams
    with the highest win percentages among them are chosen to be seeds #5, #6, and #7, known as the "wild cards." 
    If a win percentage equivalence between 2 or more Teams gets in the way of seeding the top 3, or even 
    deciding which Teams make the cutoff, the tie breaker rules are applied.

Ok cool so then... what are these tie breaker rules?

    Step 0. Previous to applying the steps, the Teams must already have to have been proven to have the same
            win percentages. Otherwise why are we even here.
    Step 1. Compare amount of wins. It's possible for two Teams to have different win-loss-tie records and 
            still end up with the same win percentage. For example, both the records of 6-4-0 and 5-3-2 result
            in a win percentage of 0.6, but in this case we would rank the Team with 6 wins higher than the 
            one with only 5.
    Step 2. Compare net points. If both Teams ended up with the same amount of wins, then we shift our 
            attention to their net points statistic. For example, if one Team ended up with 16 net points 
            and the other ended up with -3 net points, then we would rank the former higher than the latter.
    Step 3. Give up. Ok not really, just rank the teams alphabetically.

1.3.3. Playoffs

The Playoffs consist of four rounds: the Wild Card Round (6 Matches), the Divisional Round (4 Matches),
the Conference Finals (2 Matches), and the BIG BOWL (1 Match for a total of 13 Matches).
During the Playoffs, a Match is NOT allowed to end in a tie, so there's always a conclusive winner.

The Wild Card Round is named that way because the "wild cards" are given the chance to beat the Group champions 
and move on to the next round. 
Specifically, the Team seeded #2 plays against seed #7, #3 against #6, and #4 against #5. Seed #1 is said to
have a Bye and is able to qualify directly for the next round. Needless to say, the winners of these 3 Matches
move on to the next round.
This procedure is applied to both Conference brackets, so the total of Matches played is 6.

The Divisional Round... already has a weird name, and it's made worse by the fact that we call them Groups 
and not Divisions. Name notwithstanding, this sees the winners of the previous round plus the #1 seeded Team
play the following Matches:
Seed #1 plays against the lowest seed that qualified for this round. For example, if the winners of the
pervious round are seeds #2, #4, and #6, then this Match will be played between seed #1 and seed #6.
The other two Teams then play Match against each other. Per the previous example, the second Match would be
played between seeds #2 and #4. The winners move on the next round. Obviously.
This procedure is applied to both Conference brackets, so the total of Matches played is 4.

The Conference Finals are exactly what they sound like. The two Teams that qualified for this round duke it
out to find out which one is going to the BIG BOWL, no seed shenanigans needed. The winner of the Match is
also declared to be the Conference champion.
This applies to both Conferences of course. That way we have the two Teams that will play the BIG BOWL.

Finally, the most important round, consisting of a single Match, is the BIG BOWL. This sees both 
Conference champions fight for the title of Tournament champion. Simple as that.

1.4. Note 

If you still don't get it, tell me so I can show you a Tournament example in person and step you through
everything. I was going to do it here but nah. 


2. API REQUESTS

Now that you've skipped to here, I'm gonna explain the API request specifications that the professor 
expects us to implement, and how to align them to our specific project.

2.1. Controllers and Delegates

From what I understand, an object's Controller is in charge of handling the HTTP requests. It first 
transforms the body into an actual instance of the object and sends it to the Delegate to be processed.
It then either receives the expected response or catches an error, and from that craftes a reponse to
the HTTP request with the correct response code.
Meanwhile, the object's Delegate receives the object [QUALIFI STRUCUTRE] and sends it to the object's
Repository to actually interact with the database. The Delegate expects a succesful operation in the 
database. Depending on if this expectation is met or not, the Delegate returns the appropriate value,
error, or message for the Controller to interpret.

We have to implement the logic for handling several cases of request bodies sent to several URIs, and 
for every such case we have to create a test that verifies a correct implementation. 

Controller tests check for: 

    A correct transformation of the request body from JSON to object (if necessary)
    This is done by sending an object to basically copy the object created by the Controller's function 
    and then comparing this object's components to the original JSON request body. (See the example in
    TeamControllerTest.cpp > SaveTeamTest)

    Validation that the correct object was sent to the corresponding Delegate
    This is done by expecting the Controller to have its mock Delegate object call its own function
    with the exact value that we want. (See the example in TeamControllerTest.cpp > GetTeamById)

    Validation that the correct HTTP response code was returned
    This is done by expecting the result of the mock Delegate's function to be a certain value or 
    error and then validating that the Controller returned the appropriate HTTP response code (See the
    example in TeamControllerTest.cpp > GetTeamNotFound, or basically any test there)

Delegate tests check for:

    Validation that the correct object was sent to the corresponding Repository
    This is done by expecting the Delegate to have its mock Repository object call its own function
    with the exact value that we want. 

    Validation that the correct value/error was returned
    This is done by having the Delegate's code return an object of class "expected" (C++23) constructed
    upon the possible values that the mock Repository's function could return and then comparing its 
    returned value in the test with the value/error that we expect.

2.2. Teams

The body of a Team in JavaScript Object Notation is {"id":"team-id","name":"team-name"}. The ID of the
team is assigned by the database at the time of creation.
In the logic.cpp implementation, a Team object also has the attributes conference (string) and netPoints
(integer). The conference tag was a suggestion by the professor, however I do not believe it is necessary,
as we can simply divide logically the first 4 Groups into the first Conference and the other 4 in the 
second one. As for netPoints, this will be a pain to implement (not impossible, we can use some clever 
database view tricks) but we don't need to do that yet.

2.2.1. URI: /teams

For this URI, there are two methods we must account for.

POST - This creates a Team. It receives only the name {"name":"team-name"} and the ID is generated 
automatically. In the case it receives a correct body, the function that processes this request must

=================================================================
blah blah blah ill finish this later i just need yall to get goin
im pushing this rn, the instructions on what the tests should check for are literally
in the blackboard document just use that for now